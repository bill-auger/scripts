#!/bin/bash

read -r -d '' USAGE <<-'USAGE_END'
USAGE:

        vm [ -h | --help | <img> | <img-dir> | -l | --list | <n> ]

    where: <img> is the path to an .img file
    where: <img-dir> is one of `ls -d $VM_DIR/*/`
    where: <n> is one of the numbered selections of `vm --list`


ENVIRONMENT:

    * VM_DIR       - (mandatory) full path to parent directory of VM subdirectories
    * ARCH         - (optional)  launches qemu-system-$ARCH (default: 'x86_64 + kvm + smp')
    * MEM          - (optional)  specifies VM memory size (default: 1G)
    * ISO          - (optional)  .iso file for first optical disc - set as primary boot media (default: none)
    * IMG_B        - (optional)  .img file for second hard disk (default: none)
    * SMP          - (optional)  SMP options as CSV: N_CORES,N_THREADS,N_SOCKETS (default: 2,1,1)
    * VM_SSH_PORT  - (optional)  external port to bind to internal port tcp/22
    * VM_HTTP_PORT - (optional)  external port to bind to internal port tcp/80
    * VM_SSH_LOGIN - (optional)  internal ssh user to login (if VM_SSH_PORT and VM_WAIT_SSH defined)
    * VM_WAIT_SSH  - (optional)  pause before ssh login (if VM_SSH_PORT and VM_SSH_LOGIN defined)


EXAMPLES:

    vm                     # present a alphabetical list of VMs and wait for choice
    vm /home/me/vm.img     # launch a VM by absolute or relative path to an image file
    vm img-dir             # launch $VM_DIR/img-dir/img-dir.img if it exists
    vm -h (or --help)      # present this message then quit
    vm -l (or --list)      # present a alphabetical list of VMs then quit
    vm 1                   # launch a VM by it's current order number from `vm --list`
    ARCH=i386          vm  # launch 32-bit x86 VM
    MEM=1G             vm  # launch VM using 1GB of system memory
    ISO=/path/to/iso   vm  # boot from .iso file
    IMG_B=/path/to/img vm  # mount second hard disk
    VM_SSH_PORT=       vm  # do not forward ssh
    VM_HTTP_PORT=      vm  # do not forward http
    VM_SSH_LOGIN=      vm  # forward ssh but do not login
    VM_WAIT_SSH=60     vm  # wait N seconds to login
USAGE_END
readonly HAS_LIST_SWITCH=$([ "$1" == "-l" -o "$1" == "--list" ] && echo 1 || echo 0)
readonly HAS_HELP_SWITCH=$([ "$1" == "-h" -o "$1" == "--help" ] && echo 1 || echo 0)
readonly IMG_NAME_OR_N=$1                                          # pending validation
readonly IMG_FULL_PATH="$VM_DIR/$IMG_NAME_OR_N/$IMG_NAME_OR_N.img" # pending validation
readonly VM_DIR_ERR_MSG="VM_DIR must be defined in the environment"
declare -r -a IMG_DIRS=( $(
  for img_full_path in $(ls -d $VM_DIR/*/*.img 2> /dev/null)
  do  img=$(basename $img_full_path)
      dir=$(basename $(dirname $img_full_path))
      grep "^$dir\.img$" <<<$img > /dev/null && echo $dir
  done
) )
readonly N_IMG_DIRS=${#IMG_DIRS[@]}

Selection= # deferred
ImgDir=    # deferred


function doesImgExist { [ -f "$1" -a "$(echo $1 | grep -E '^.+\.img$')" == "$1" ] ; }

function isValidSelection # (img_n)
{
  local img_n=$(sed -E 's|^([0-9]+)$|\1|' <<<$1) ; [ "$img_n" ] || img_n=-1 ;

  [[ "$img_n" -ge "0" ]] && [[ "$img_n" -le "$N_IMG_DIRS" ]]
}

function isVmSelection # (img_n)
{
  isValidSelection $img_n && [[ "$img_n" -ne "0" ]]
}

function selectImage # (img_n)
{
  local img_n=$1
  Selection=$(isValidSelection $img_n && echo $img_n || echo -1)

  until isValidSelection $Selection
  do    for img_dir_n in "${!IMG_DIRS[@]}"; do echo "$(($img_dir_n+1))) ${IMG_DIRS[$img_dir_n]}" ; done ;
        if   (( $HAS_LIST_SWITCH ))
        then Selection=0
        else echo -n "choice (1-$N_IMG_DIRS, 0=quit): " ; read Selection ;
             isValidSelection $Selection || echo "Selection ($Selection) out of range"
     fi
  done

  (( $N_IMG_DIRS )) || echo "no suitable images found in \$VM_DIR '$VM_DIR'"
  ImgDir=${IMG_DIRS[$(( $Selection - 1 ))]}
}

function waitSsh
{
  ssh-keygen -f "~/.ssh/known_hosts" -R [localhost]:$VM_SSH_PORT
  while (($WAIT_SSH > 0))
  do    WAIT_SSH=($WAIT_SSH-1)
        clear ; echo "logging in ssh in $(($WAIT_SSH+1)) seconds" ;
        sleep 1
  done
}


## main entry ##

(( $HAS_HELP_SWITCH )) && echo "$USAGE"          && exit
[ -z "$VM_DIR" ]       && echo "$VM_DIR_ERR_MSG" && exit

# determine which VM image to launch
if   [ "$IMG_NAME_OR_N" ] && ! isValidSelection $IMG_NAME_OR_N
then for img in "$IMG_NAME_OR_N" "$IMG_FULL_PATH" ; do doesImgExist $img && IMG=$img ; done ;
     [ "$IMG" ] || echo "IMG not found at '$img' or '$IMG_FULL_PATH'"
fi
until doesImgExist $IMG
do    selectImage $IMG_NAME_OR_N

      IMG=$VM_DIR/$ImgDir/$ImgDir.img
      ! doesImgExist $IMG && clear && echo "HD image '$img' not found"
done

# prepare the environment
# BOOT="-boot menu=on"
SMP_REGEX="^[0-9],[0-9],[0-9]$" N_CORES=2 N_THREADS=1 N_SOCKETS=1
[[ "$SMP" =~ $SMP_REGEX ]] && N_CORES=${BASH_REMATCH[1]} N_THREADS=${BASH_REMATCH[2]} N_SOCKETS=${BASH_REMATCH[3]}
[[ -z "$ARCH"           ]] && ARCH="x86_64"
[[ "$ARCH" == 'x86_64'  ]] && CPU="-cpu host -smp cores=$N_CORES,threads=$N_THREADS,sockets=$N_SOCKETS"
[[ "$ARCH" == 'x86_64'  ]] && ARCH="x86_64 -enable-kvm"
[[ "$ImgDir"            ]] && NAME="-name $ImgDir"
[[ "$IMG_B"             ]] && HD="-drive file=$IMG_B,format=raw,cache=writeback"
[[ -f "$ISO"            ]] && CD="-cdrom $ISO" BOOT="-boot order=d"                 || CD="" BOOT=""
[[ "$MEM"               ]] && MEM="-m $MEM"                                         || MEM="-m 1G"
[[ "$VGA"               ]] && VGA="-vga $VGA"                                       || VGA="-vga std" # cirrus, qxl, std, vmware
[[ "$VM_SSH_PORT"       ]] && FWD_SSH=",hostfwd=tcp::$VM_SSH_PORT-:22"              || FWD_SSH=''
[[ "$VM_HTTP_PORT"      ]] && FWD_HTTP=",hostfwd=tcp::$VM_HTTP_PORT-:$VM_HTTP_PORT" || FWD_HTTP=''
QEMU="qemu-system-$ARCH $NAME"
HD="-drive file=$IMG,format=raw,cache=writeback $HD"

# prepare networking
readonly USE_VIRTIO=0
readonly USE_VIRTFS=0
readonly USE_VIRTSMB=0
SHARED_DIR_DEFAULT=$HOME/.config/vm-shared
[[ ! -d "$SHARED_DIR" ]] && [[ -d "$SHARED_DIR_DEFAULT" ]] && SHARED_DIR=$SHARED_DIR_DEFAULT
NET_VIRTIO="-netdev user,id=vmnic$FWD_SSH$FWD_HTTP -device virtio-net,netdev=vmnic"
NET_VIRTSMB="-net user,smb=\"$SHARED_DIR\" -net nic,model=virtio"
NET_VIRTFS="-virtfs local,path=\"$SHARED_DIR\",mount_tag=host0,security_model=passthrough,id=host0"
#     (( $USE_VIRTIO )) && NET="$NET_VIRTIO" || NET=''
if   ((   $USE_VIRTIO ))
then NET="$NET_VIRTIO"
elif ((   $USE_VIRTSMB ))
then NET="$NET_VIRTSMB"
elif ((   $USE_VIRTFS ))
then NET="$NET_VIRTFS" # guest fstab entry: host0 /a-mountpoint 9p trans=virtio,version=9p2000.L 0 0
else NET=''
fi

# prepare SSH
SSH="ssh -o StrictHostKeyChecking=no -p $VM_SSH_PORT $VM_SSH_LOGIN@localhost"
# SSH="-redir tcp:$VM_SSH_PORT::22" # no virtio - deprecated
[ "$VM_SSH_PORT" -o "$VM_HTTP_PORT"          ] || NET=''
[ "$VM_SSH_PORT" -a "$VM_SSH_LOGIN"          ] || SSH=''
[ "`echo $VM_WAIT_SSH | grep -E '^[1-9]+$'`" ] || WAIT_SSH=30

# prepare A/V
AUDIO="-soundhw hda"
#VIDEO_SDL="-display sdl -no-frame"
VIDEO_SDL="-display sdl"
VIDEO_VNC="-display vnc=:0"
VIDEO="$VIDEO_SDL"
MISC="-show-cursor"


# load virtio kernel modules
if   (( $USE_VIRTIO ))
then virtio_modules=`lsmod | grep virtio`
     [ "`echo $virtio_modules | grep virtio_net`"    == "" ] && su -c 'modprobe virtio-net'
     #[ "`echo $virtio_modules | grep virtio_blk`"     == "" ] && su -c 'modprobe virtio-blk'
     #[ "`echo $virtio_modules | grep virtio_scsi`"    == "" ] && su -c 'modprobe virtio-scsi'
     #[ "`echo $virtio_modules | grep virtio_serial`"  == "" ] && su -c 'modprobe virtio-serial'
     #[ "`echo $virtio_modules | grep virtio_balloon`" == "" ] && su -c 'modprobe virtio-balloon'
fi

# concatenate command line and report
echo "launching vm: '`echo "$IMG" | grep -E '^.+\.img$' | sed -e 's/^\(.*\/\)\?\(.*\).img$/\2/'`'"
CMD="$QEMU $CPU $MEM $HD $CD $BOOT $VGA $NET $AUDIO $VIDEO $MISC"
echo "$CMD"

# launch VM and optionally login ssh
[ "$FWD_SSH"  ] && echo "SSH port 22 forwarded to localhost:$VM_SSH_PORT"
[ "$FWD_HTTP" ] && echo "HTTP port $VM_HTTP_PORT forwarded to localhost:$VM_HTTP_PORT"
if   [ "$SSH" -a "$WAIT_SSH" ]
then $CMD & waitSsh && $SSH
else $CMD
fi
